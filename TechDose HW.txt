## 1. Conversion Between Number Bases
### a. Convert (1012) base 2 to base 10
To convert binary (base 2) to decimal (base 10):

\[ 1012_2 = 1 \times 2^3 + 0 \times 2^2 + 1 \times 2^1 + 2 \times 2^0 \]

However, this question seems to involve a typo as binary can only contain the digits 0 and 1. Please check the binary number.

### b. Convert (237) base 8 to base 2
To convert octal (base 8) to binary (base 2), convert each digit of the octal number to its 3-bit binary equivalent.

- \( 2_8 = 010_2 \)
- \( 3_8 = 011_2 \)
- \( 7_8 = 111_2 \)

So, \( 237_8 = 010011111_2 \).

### c. Convert (535) base 9 to base 10
To convert base 9 to base 10:

\[ 535_9 = 5 \times 9^2 + 3 \times 9^1 + 5 \times 9^0 = 437_{10} \]

## 2. Logarithm Properties
- **Product Rule**: \( \log_b (xy) = \log_b x + \log_b y \)
- **Quotient Rule**: \( \log_b \left(\frac{x}{y}\right) = \log_b x - \log_b y \)
- **Power Rule**: \( \log_b (x^y) = y \log_b x \)
- **Change of Base Formula**: \( \log_b x = \frac{\log_k x}{\log_k b} \)
- **Log of 1**: \( \log_b 1 = 0 \)
- **Log of the Base**: \( \log_b b = 1 \)

## 3. 1's Complement and 2's Complement
- **1's Complement**: Flip all the bits (0 to 1, 1 to 0).
- **2's Complement**: Add 1 to the 1's complement.

**Practical Application**: Used in representing negative numbers in binary systems. It's the standard way to encode negative integers in computers.

## 4. Power of 2 Code Implementation

```cpp
bool isPowerOfTwo(int n) {
    return (n > 0) && ((n & (n - 1)) == 0);
}
```

This function checks if a number is a power of 2 by verifying that only one bit is set.

## 5. Representing Positive and Negative Numbers
- **Positive Numbers**: Use standard binary representation.
- **Negative Numbers**: Use 2's complement.

## 6. Adding and Subtracting in Binary
- **Addition**: Follow the same process as decimal addition, with carries.
- **Subtraction**: Use the 2's complement of the number to be subtracted and add it.

## 7. Operator Precedence Table

In C++:
1. `()` `[]` `->` `.`
2. `++` `--` `+` `-` `*` `/` `%`
3. `<<` `>>`
4. `<` `<=` `>` `>=`
5. `==` `!=`
6. `&`
7. `^`
8. `|`
9. `&&`
10. `||`
11. `=` `+=` `-=` `*=` `/=`

## 8. Leading and Trailing Zeroes
- **Leading Zeroes**: Zeros that appear before the first non-zero digit.
- **Trailing Zeroes**: Zeros that appear after the last non-zero digit.

## 9. Significant Zeroes
- **Significant Zeroes**: Zeros between non-zero digits or after a non-zero digit and a decimal point.

## 10. Bit Masking
Bit masking involves using a mask (a binary number) to isolate or manipulate specific bits within a binary number.

## 11. Code Implementations
### a. Count Set Bits
```cpp
int countSetBits(int n) {
    int count = 0;
    while (n) {
        count += n & 1;
        n >>= 1;
    }
    return count;
}
```

### b. Check if ith Bit is Set
```cpp
bool isIthBitSet(int n, int i) {
    return (n & (1 << i)) != 0;
}
```

### c. Set the ith Bit
```cpp
int setIthBit(int n, int i) {
    return n | (1 << i);
}
```

### d. Unset the ith Bit
```cpp
int unsetIthBit(int n, int i) {
    return n & ~(1 << i);
}
```

### e. Generate All Possible Subsets of an Array
```cpp
void generateSubsets(vector<int>& arr) {
    int n = arr.size();
    for (int i = 0; i < (1 << n); i++) {
        vector<int> subset;
        for (int j = 0; j < n; j++) {
            if (i & (1 << j)) {
                subset.push_back(arr[j]);
            }
        }
        // Process subset (e.g., print it)
    }
}
```

### f. Swapping Two Numbers
```cpp
void swap(int &a, int &b) {
    a = a ^ b;
    b = a ^ b;
    a = a ^ b;
}
```

### g. Odd or Even
```cpp
bool isEven(int n) {
    return (n & 1) == 0;
}
```

### h. Upper to Lower Case
```cpp
char toLowerCase(char c) {
    return c | ' ';
}
```

### i. Toggle the ith Bit
```cpp
int toggleIthBit(int n, int i) {
    return n ^ (1 << i);
}
```
```